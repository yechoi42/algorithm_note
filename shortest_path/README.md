# 최단 경로 문제
다양한 문제 상황
- 한 지점에서 다른 한 지점
- 한 지점에서 다른 모든 지점
- 모든 지점에서 다른 모든 지점

각 지점은 그래프에서 노드로 표현, 연결된 도로는 간선으로 표현


# 다익스트라 알고리즘
특정한 노드에서 출발해 다른 모든 노드로 가는 최단 경로
음의 간선이 없을 때 정상적으로 동작
그리디 알고리즘으로 분류: 매 상황에서 가장 비용이 적은 노드를 선택해 임의의 과정 반복
cf. DP로 분류되기도 함

## 동작과정
1. 출발 노드를 설정
2. 최단 거리 테이블을 초기화(다른 노드 무한, 자신 노드 0)
3. 방문하지 않은 노드 중 최단 거리가 가장 짧은 노드를 선택
4. 해당 노드를 거쳐 다른 노드를 가는 비용을 계산해 최단 거리 테이블 "갱신"
5. 위 과정에서 3, 4번을 반복

## 리스트를 활용한 다익스트라 성능 분석
총 O(V)번에 걸쳐 최단거리가 가장 짧은 노드를 매번 선형 탐색
전체적인 시간 복잡도는 O(V^2)
전체 노드 개수가 5000개 이하라면 다익스트라로 문제 해결 가능
10000개 이상이라면 연산이 1억 이상! -> 어떻게 접근해야 할까?

## 우선순위 큐를 적용한 다익스트라 성능 분석
힙을 사용해 구현하면 삽입시간, 삭제시간이 모두 O(logN)
```
import heapq
```
전체적인 다익스트라 알고리즘의 시간 복잡도는 O(ElogV)
E개의 원소를 우선순위 큐에 넣었다가 모두 빼내는 연산과 유사


# 플로이드 워셜 알고리즘
모든 노드에서 다른 모든 노드까지의 최단경로 
2차원 테이블에 최단거리 정보를 저장
DP 유형에 속함 - 점화식을 통한 3중 반복문으로 2차원 테이블 갱신
시간복잡도는 O(N^3)으로 노드의 갯수가 적을 때 사용할 수 있음 

## 점화식
각 단계마다 특정한 노드 k를 거쳐가는 경우를 확인
- a에서 b로 가는 최단 거리보다 a에서 k를 거쳐 b로 가는 거리가 더 짧은지 검사

```
D_{ab} = min(D_{ab}, D_{ak} + D_{kb})
```

## 동작과정
1. 그래프를 준비하고 연결된 노드 간 거리를 입력
2. 점화식을 사용해 k번째 노드를 거쳐가는 경우를 고려해 테이블 갱신
-  이 과정에서 k를 결정하는 데 반복문 사용
-  그 반복문 안에서 a와 b의 경우를 따질 때 이중 반복문 사용
